/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.strangegrotto.wealthdraft;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.encoder.PatternLayoutEncoder;
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.ConsoleAppender;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.type.MapType;
import com.fasterxml.jackson.databind.type.TypeFactory;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
import com.fasterxml.jackson.datatype.guava.GuavaModule;
import com.google.common.base.Strings;
import com.strangegrotto.wealthdraft.errors.GError;
import com.strangegrotto.wealthdraft.errors.ValueOrGError;
import com.strangegrotto.wealthdraft.govconstants.GovConstantsForYear;
import com.strangegrotto.wealthdraft.govconstants.RetirementConstants;
import com.strangegrotto.wealthdraft.scenarios.IncomeStreams;
import com.strangegrotto.wealthdraft.scenarios.Scenario;
import com.strangegrotto.wealthdraft.tax.*;
import com.strangegrotto.wealthdraft.validator.ValidationWarning;
import net.sourceforge.argparse4j.ArgumentParsers;
import net.sourceforge.argparse4j.helper.HelpScreenException;
import net.sourceforge.argparse4j.inf.ArgumentParser;
import net.sourceforge.argparse4j.inf.ArgumentParserException;
import net.sourceforge.argparse4j.inf.Namespace;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.text.DecimalFormat;
import java.time.Year;
import java.util.*;

public class Main {
    private static final int SUCCESS_EXIT_CODE = 0;
    private static final int FAILURE_EXIT_CODE = 1;

    private static final String SCENARIOS_FILEPATH_ARG = "scenarios";
    private static final String GOV_CONSTANTS_FILEPATH_ARG = "gov-constants";
    private static final String LOG_LEVEL_ARG = "log-level";

    private static final String LOGBACK_LAYOUT_PATTERN = "%highlight(%-5level) %logger{0} - %message%n";

    private static final int MINIMUM_ITEM_TITLE_WIDTH = 30;
    private static final int MINIMUM_CURRENCY_WIDTH = 9;
    private static final String SUM_LINE = Strings.repeat(" ", MINIMUM_ITEM_TITLE_WIDTH + 2)
            + Strings.repeat("-", MINIMUM_CURRENCY_WIDTH);
    private static final DecimalFormat CURRENCY_FORMAT = new DecimalFormat  ("###,##0");
    private static final DecimalFormat PERCENT_FORMAT = new DecimalFormat("##.#%");

    private static final Logger log = LoggerFactory.getLogger(Main.class);

    public static void main(String[] args) {
        Logger slf4jRootLogger = org.slf4j.LoggerFactory.getLogger(ch.qos.logback.classic.Logger.ROOT_LOGGER_NAME);
        ch.qos.logback.classic.Logger logbackRootLogger = (ch.qos.logback.classic.Logger) slf4jRootLogger;
        configureRootLoggerPattern(logbackRootLogger);

        ArgumentParser parser = ArgumentParsers.newFor("Financial Predictor").build()
                .defaultHelp(true)
                .description("A financial modelling CLI");
        parser.addArgument("--" + SCENARIOS_FILEPATH_ARG)
                .dest(SCENARIOS_FILEPATH_ARG)
                .required(true)
                .help("YAML file containing scenarios to calculate");
        parser.addArgument("--" + GOV_CONSTANTS_FILEPATH_ARG)
                .dest(GOV_CONSTANTS_FILEPATH_ARG)
                .required(true)
                .help("YAML file of gov constants per year");
        parser.addArgument("--" + LOG_LEVEL_ARG)
                .dest(LOG_LEVEL_ARG)
                .type(Level.class)
                .setDefault(Level.INFO)
                .choices(Level.TRACE, Level.DEBUG, Level.INFO, Level.WARN, Level.ERROR)
                .help("Log level to output at");

        Namespace parsedArgs;
        try {
            parsedArgs = parser.parseArgs(args);
        } catch (HelpScreenException e) {
            // For some strange reason, argparse4j throws an exception on help
            System.exit(SUCCESS_EXIT_CODE);
            return;
        } catch (ArgumentParserException e) {
            log.error("An error occurred parsing the CLI args", e);
            System.exit(FAILURE_EXIT_CODE);
            return;
        }

        Level logLevel = parsedArgs.get(LOG_LEVEL_ARG);
        logbackRootLogger.setLevel(logLevel);

        ObjectMapper mapper = new ObjectMapper(new YAMLFactory());
        mapper.registerModules(new GuavaModule());
        TypeFactory typeFactory = mapper.getTypeFactory();

        String scenariosFilepath = parsedArgs.getString(SCENARIOS_FILEPATH_ARG);
        log.debug("Scenarios filepath: {}", scenariosFilepath);
        MapType scenariosMapType = typeFactory.constructMapType(HashMap.class, String.class, Scenario.class);
        Map<String, Scenario> scenarios;
        try {
            scenarios = mapper.readValue(new File(scenariosFilepath), scenariosMapType);
        } catch (IOException e) {
            log.error("An error occurred parsing scenarios file '{}'", scenariosFilepath, e);
            System.exit(FAILURE_EXIT_CODE);
            return;
        }

        String govConstantsFilepath = parsedArgs.getString(GOV_CONSTANTS_FILEPATH_ARG);
        log.debug("Gov constants filepath: {}", govConstantsFilepath);
        MapType govConstantsMapType = typeFactory.constructMapType(HashMap.class, Integer.class, GovConstantsForYear.class);
        Map<Integer, GovConstantsForYear> allGovConstants;
        try {
            allGovConstants = mapper.readValue(new File(govConstantsFilepath), govConstantsMapType);
        } catch (IOException e) {
            log.error("An error occurred parsing gov constants file '{}'", govConstantsFilepath, e);
            System.exit(FAILURE_EXIT_CODE);
            return;
        }

        Integer latestYear = Collections.max(allGovConstants.keySet());
        GovConstantsForYear latestGovConstants = allGovConstants.get(latestYear);

        if (Year.now().getValue() != latestYear) {
            log.warn("The latest gov constants we have are old, from {}!!!", latestYear);
        }

        for (Map.Entry<String, Scenario> entry : scenarios.entrySet()) {
            String name = entry.getKey();
            Scenario scenario = entry.getValue();

            log.info("======================= {} ======================", name);
            GError err = calculateScenario(scenario, latestGovConstants);
            if (err != null) {
                log.error(err.toString());
            }
        }
    }

    private static void configureRootLoggerPattern(ch.qos.logback.classic.Logger rootLogger) {
        // Configure the logger with our desired pattern
        // See: http://logback.qos.ch/manual/layouts.html
        LoggerContext loggerContext = rootLogger.getLoggerContext();
        loggerContext.reset();

        PatternLayoutEncoder encoder = new PatternLayoutEncoder();
        encoder.setContext(loggerContext);
        encoder.setPattern(LOGBACK_LAYOUT_PATTERN);
        encoder.start();

        ConsoleAppender<ILoggingEvent> appender = new ConsoleAppender<>();
        appender.setContext(loggerContext);
        appender.setEncoder(encoder);
        appender.start();

        rootLogger.addAppender(appender);
    }

    private static GError calculateScenario(
            Scenario scenario,
            GovConstantsForYear govConstants) {
        ValueOrGError<List<ValidationWarning>> validationResult = validateScenarioAgainstConstants(scenario, govConstants);
        if (validationResult.hasError()) {
            return GError.propagate(validationResult.getError(), "An error occurred validating the scenario against the latest gov constants");
        }
        List<ValidationWarning> validationWarnings = validationResult.getValue();
        if (validationWarnings.size() > 0) {
            logSectionHeader("WARNINGS");
            for (ValidationWarning warning : validationWarnings) {
                log.warn(warning.getMessage());
            }
            log.warn("");
        }

        logSectionHeader("RETIREMENT");
        logCurrencyItem("Trad 401k Contrib", scenario.get401kContrib().getTrad());
        logCurrencyItem("Roth 401k Contrib", scenario.get401kContrib().getRoth());
        logCurrencyItem("Trad IRA Contrib", scenario.getIraContrib().getTrad());
        logCurrencyItem("Roth IRA Contrib", scenario.getIraContrib().getRoth());

        IncomeStreams grossIncomeStreams = scenario.getIncomeStreams();

        log.info("");
        logSectionHeader("GROSS INCOME");
        logCurrencyItem("Earned Income", grossIncomeStreams.getEarnedIncome());
        logCurrencyItem("Longterm Cap Gains", grossIncomeStreams.getLongTermCapGains());
        logCurrencyItem("Shortterm Cap Gains", grossIncomeStreams.getShortTermCapGains());
        logCurrencyItem("Other Unearned Income", grossIncomeStreams.getOtherUnearnedIncome());
        log.info(SUM_LINE);
        long grossIncome = grossIncomeStreams.getEarnedIncome()
                + grossIncomeStreams.getLongTermCapGains()
                + grossIncomeStreams.getShortTermCapGains()
                + grossIncomeStreams.getOtherUnearnedIncome();
        logCurrencyItem("Gross Income", grossIncome);

        Map<Tax, Double> ficaTaxes = FicaTaxCalculator.calculateFicaTax(scenario, govConstants);
        Double totalFicaTax = ficaTaxes.values().stream()
                .reduce(0D, (l, r) -> l + r);
        renderTaxesSection("FICA Tax", ficaTaxes, grossIncome);

        Map<Tax, Double> regFedIncomeTaxes = RegularIncomeTaxCalculator.calculateRegularIncomeTax(scenario, govConstants);
        renderTaxesSection("Reg Fed Income Tax", regFedIncomeTaxes, grossIncome);

        Map<Tax, Double> amtTaxes = AmtTaxCalculator.calculateAmtTax(scenario, govConstants);
        renderTaxesSection("AMT", amtTaxes, grossIncome);

        /*
        log.info(SUM_LINE);
        double totalTax = taxes.values().stream()
                .reduce(0D, (l, r) -> l + r);
        log.info("Total Tax: {}", totalTax);
        double marginalTaxRate = totalTax / (double)grossIncome;
        log.info("Effective Tax Rate: {}", marginalTaxRate);
        log.info("");
         */

        return null;
    }

    private static ValueOrGError<List<ValidationWarning>> validateScenarioAgainstConstants(Scenario scenario, GovConstantsForYear govConstantsForYear) {
        IncomeStreams grossIncomeStreams = scenario.getIncomeStreams();

        List<ValidationWarning> warnings = new ArrayList<>();

        RetirementConstants retirementConstants = govConstantsForYear.getRetirementConstants();
        long totalIraContrib = scenario.getIraContrib().getTrad() + scenario.getIraContrib().getRoth();
        if (totalIraContrib > retirementConstants.getIraContribLimit()) {
            return ValueOrGError.ofError(GError.newError(
                    "The IRA contribution limit is {} but the scenario's total IRA contribution is {}",
                    retirementConstants.getIraContribLimit(),
                    totalIraContrib
            ));
        }
        if (totalIraContrib < retirementConstants.getIraContribLimit()) {
            warnings.add(ValidationWarning.of(
                    "The IRA contribution limit {} but the scenario's total IRA contribution is only {}",
                    retirementConstants.getIraContribLimit(),
                    totalIraContrib
            ));
        }

        long trad401kContrib = scenario.get401kContrib().getTrad();
        long total401kContrib = trad401kContrib + scenario.get401kContrib().getRoth();
        if (total401kContrib > govConstantsForYear.getRetirementConstants().getPersonal401kContribLimit()) {
            return ValueOrGError.ofError(GError.newError(
                    "The 401k contribution limit is {} but the scenario's total 401k contribution is {}",
                    retirementConstants.getPersonal401kContribLimit(),
                    total401kContrib
            ));
        }
        if (total401kContrib < retirementConstants.getPersonal401kContribLimit()) {
            warnings.add(ValidationWarning.of(
                    "The IRA contribution limit {} but the scenario's total 401k contribution is only {}",
                    retirementConstants.getPersonal401kContribLimit(),
                    total401kContrib
            ));
        }

        // IRA contributions MUST be done with earned income, and trad 401k contributions can
        //  only be done via an employer (i.e. earned income) so total_ira_contrib + trad_401k_contrib must be
        // See: https://www.investopedia.com/retirement/ira-contribution-limits/
        if (grossIncomeStreams.getEarnedIncome() < totalIraContrib + trad401kContrib) {
            return ValueOrGError.ofError(GError.newError(
                    "IRA contributions are limited to earned income and trad 401k contributions can only be done " +
                            "using earned income so total_ira_contrib + trad_401k_contrib must be < earned_income, but" +
                            "earned_income {} is < total_ira_contrib {} + trad_401k_contrib {}",
                    grossIncomeStreams.getEarnedIncome(),
                    totalIraContrib,
                    trad401kContrib
            ));
        }

        return ValueOrGError.ofValue(warnings);
    }

    private static void logSectionHeader(String header) {
        header = header.toUpperCase();
        // We add 2 to account for the ": " that each item entry has
        int totalWidth = 2 * MINIMUM_ITEM_TITLE_WIDTH + 2;
        int spacesToAdd = (totalWidth - header.length()) / 2;
        log.info(
                "{}{}",
                Strings.repeat(" ", spacesToAdd),
                header
        );
    }

    private static void logCurrencyItem(String title, Object value) {
        log.info(
                "{}: {}",
                String.format("%1$" + MINIMUM_ITEM_TITLE_WIDTH + "s", title),
                String.format(
                        "%1$" + MINIMUM_CURRENCY_WIDTH + "s",
                        CURRENCY_FORMAT.format(value)
                )
        );
    }

    private static void renderTaxesSection(String titleCaseSumName, Map<Tax, Double> taxes, long grossIncome) {

        log.info("");
        logSectionHeader(titleCaseSumName);
        double totalTaxes = 0D;
        for (Map.Entry<Tax, Double> entry : taxes.entrySet()) {
            double tax = entry.getValue();
            totalTaxes += tax;
            String prettyName = entry.getKey().getPrettyName();
            logCurrencyItem(prettyName, tax);
        }
        double effectiveTaxRate = totalTaxes / (double)grossIncome;
        log.info(SUM_LINE);
        String itemTitle = "Total " + titleCaseSumName;
        log.info(
                "{}: {} ({} effective tax rate)",
                String.format("%1$" + MINIMUM_ITEM_TITLE_WIDTH + "s", itemTitle),
                String.format(
                        "%1$" + MINIMUM_CURRENCY_WIDTH + "s",
                        CURRENCY_FORMAT.format(totalTaxes)
                ),
                PERCENT_FORMAT.format(effectiveTaxRate)
        );
    }
}
