/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.strangegrotto.wealthdraft;

import ch.qos.logback.classic.Level;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.type.MapType;
import com.fasterxml.jackson.databind.type.TypeFactory;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
import com.strangegrotto.wealthdraft.errors.ValueOrError;
import com.strangegrotto.wealthdraft.govconstants.objects.GovConstantsForYear;
import com.strangegrotto.wealthdraft.scenarios.Scenario;
import net.sourceforge.argparse4j.ArgumentParsers;
import net.sourceforge.argparse4j.helper.HelpScreenException;
import net.sourceforge.argparse4j.inf.ArgumentParser;
import net.sourceforge.argparse4j.inf.ArgumentParserException;
import net.sourceforge.argparse4j.inf.Namespace;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.time.Year;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

public class Main {
    private static final String SUM_LINE = "----------------------------------------------";
    private static final int SUCCESS_EXIT_CODE = 0;
    private static final int FAILURE_EXIT_CODE = 1;

    private static final String SCENARIOS_FILEPATH_ARG = "scenarios";
    private static final String GOV_CONSTANTS_FILEPATH_ARG = "gov-constants";
    private static final String LOG_LEVEL_ARG = "log-level";

    private static final Logger LOG = LoggerFactory.getLogger(Main.class);

    public static void main(String[] args) {
        ArgumentParser parser = ArgumentParsers.newFor("Financial Predictor").build()
                .defaultHelp(true)
                .description("A financial modelling CLI");
        parser.addArgument("--" + SCENARIOS_FILEPATH_ARG)
                .required(true)
                .help("YAML file containing scenarios to calculate");
        parser.addArgument("--" + GOV_CONSTANTS_FILEPATH_ARG)
                .required(true)
                .help("YAML file of gov constants per year");
        parser.addArgument("--" + LOG_LEVEL_ARG)
                .type(Level.class)
                .setDefault(Level.INFO)
                .choices(Level.TRACE, Level.DEBUG, Level.INFO, Level.WARN, Level.ERROR)
                .help("Log level to output at");

        Namespace parsedArgs;
        try {
            parsedArgs = parser.parseArgs(args);
        } catch (HelpScreenException e) {
            // For some strange reason, argparse4j throws an exception on help
            System.exit(SUCCESS_EXIT_CODE);
            return;
        } catch (ArgumentParserException e) {
            LOG.error("An error occurred parsing the CLI args", e);
            System.exit(FAILURE_EXIT_CODE);
            return;
        }

        Level logLevel = parsedArgs.get(LOG_LEVEL_ARG);
        ((ch.qos.logback.classic.Logger) LOG).setLevel(logLevel);

        ObjectMapper mapper = new ObjectMapper(new YAMLFactory());
        TypeFactory typeFactory = mapper.getTypeFactory();

        String scenariosFilepath = parsedArgs.getString(SCENARIOS_FILEPATH_ARG);
        MapType scenariosMapType = typeFactory.constructMapType(HashMap.class, String.class, Scenario.class);
        Map<String, Scenario> scenarios;
        try {
            scenarios = mapper.readValue(new File(scenariosFilepath), scenariosMapType);
        } catch (IOException e) {
            LOG.error("An error occurred parsing scenarios file '{}'", scenariosFilepath, e);
            System.exit(FAILURE_EXIT_CODE);
            return;
        }

        String govConstantsFilepath = parsedArgs.getString(GOV_CONSTANTS_FILEPATH_ARG);
        MapType govConstantsMapType = typeFactory.constructMapType(HashMap.class, Integer.class, GovConstantsForYear.class);
        Map<Integer, GovConstantsForYear> allGovConstants;
        try {
            allGovConstants = mapper.readValue(new File(govConstantsFilepath), govConstantsMapType);
        } catch (IOException e) {
            LOG.error("An error occurred parsing gov constants file '{}'", govConstantsFilepath, e);
            System.exit(FAILURE_EXIT_CODE);
            return;
        }

        Integer latestYear = Collections.max(allGovConstants.keySet());
        GovConstantsForYear latestGovConstants = allGovConstants.get(latestYear);

        if (Year.now().getValue() != latestYear) {
            LOG.warn("The latest gov constants we have are old, from {}!!!", latestYear);
        }

        for (Map.Entry<String, Scenario> entry : scenarios.entrySet()) {
            String name = entry.getKey();
            Scenario scenario = entry.getValue();

            LOG.info("======================= {} ======================", name);

        }
    }

    private static ValueOrError<Void> calculateScenario(
            Scenario scenario,
            GovConstantsForYear govConstants) {
        return ValueOrError.ofValue(null);
    }
}
